# Trees

üü© 1. Binary Tree Traversals

Classic tree problems, foundational for DFS/BFS understanding.

‚úî Must-Solve

Binary Tree Preorder Traversal

Binary Tree Inorder Traversal

Binary Tree Postorder Traversal

Binary Tree Level Order Traversal

Binary Tree Zigzag Level Order Traversal

N-ary Tree Preorder / Postorder

Serialize / Deserialize Binary Tree

Core Patterns

DFS (recursive / iterative)

BFS (queue)

Use stack for iterative DFS

üü¶ 2. Tree Depth / Height

Problems measuring or using tree depth.

‚úî Must-Solve

Maximum Depth of Binary Tree

Minimum Depth of Binary Tree

Balanced Binary Tree

Diameter of Binary Tree

Sum of Nodes at Kth Level

Level Order Bottom-Up

Core Patterns

DFS for height calculation

BFS for level-based operations

üü• 3. Binary Search Tree (BST) Properties

Leverage BST ordering.

‚úî Must-Solve

Validate Binary Search Tree

Lowest Common Ancestor of BST

Lowest Common Ancestor of Binary Tree (generic)

Convert Sorted Array to BST

Convert BST to Greater Tree

Kth Smallest / Largest Element in BST

Range Sum of BST

Core Patterns

Recursive DFS + conditions

Inorder traversal gives sorted order

Use BST property to prune branches

üü® 4. Tree Path / Root-to-Leaf

Root-to-leaf problems often use DFS or backtracking.

‚úî Must-Solve

Path Sum (I & II)

Sum Root to Leaf Numbers

Binary Tree Maximum Path Sum

Binary Tree Paths

All Nodes Distance K in Binary Tree

Serialize / Deserialize Tree (DFS path)

Core Patterns

DFS + path list

Keep running sum

Backtrack path when returning

üü™ 5. Tree Modification / Transformation

Change tree structure or node values.

‚úî Must-Solve

Invert / Mirror Binary Tree

Flatten Binary Tree to Linked List

Construct Binary Tree from Preorder & Inorder

Construct Binary Tree from Postorder & Inorder

Populate Next Right Pointers in Each Node

Convert BST to Sorted Doubly Linked List

Core Patterns

Recursive transformations

Post-order or pre-order DFS traversal

Keep parent/child references

üü´ 6. Tree Ancestor / Distance / LCA

Find relationships between nodes.

‚úî Must-Solve

Lowest Common Ancestor

All Nodes Distance K in Binary Tree

Binary Tree Cameras

Find Duplicate Subtrees

Subtree of Another Tree

Core Patterns

Post-order DFS + return flags

Use maps for parent pointers

LCA techniques: recursion, path sets, or binary lifting

üüß 7. Binary Tree Views / Width / Boundary

Problems involving visualization of tree structure.

‚úî Must-Solve

Binary Tree Right Side View

Binary Tree Left Side View

Top View / Bottom View of Binary Tree

Maximum Width of Binary Tree

Boundary of Binary Tree

Core Patterns

BFS + level tracking

Use horizontal distance or column index

Queue or recursive DFS

üü¶ 8. Tree Serialization / Hashing / DP

Advanced tree problems using hashmaps or memoization.

‚úî Must-Solve

Serialize / Deserialize Binary Tree

Unique Binary Search Trees (Count)

Count Complete Tree Nodes

Binary Tree Maximum Path Sum

Find Duplicate Subtrees

All Possible Full Binary Trees

Core Patterns

Recursive encoding of subtree

Memoization for counting

HashMap for subtree identification

‚≠ê Top 20 Tree Problems (Essential for Interviews)

Binary Tree Preorder Traversal

Binary Tree Inorder Traversal

Binary Tree Postorder Traversal

Level Order Traversal

Maximum Depth of Binary Tree

Minimum Depth of Binary Tree

Balanced Binary Tree

Diameter of Binary Tree

Validate BST

Lowest Common Ancestor of BST

Lowest Common Ancestor of Binary Tree

Path Sum II

Binary Tree Maximum Path Sum

Binary Tree Right Side View

Flatten Binary Tree to Linked List

Serialize / Deserialize Binary Tree

Construct Binary Tree from Preorder & Inorder

Kth Smallest Element in BST

Convert Sorted Array to BST

All Nodes Distance K in Binary Tree
